ini_drops = ini_file("items\\settings\\wpo_drop_cond.ltx")
ini_prices = ini_file("items\\settings\\part_prices.ltx")
ini_parts   = itms_manager.ini_parts
-- temp condition for trade
local parts_list = {}
print_dbg 			= arti_jamming.print_dbg
has_parts 			= arti_jamming.has_parts
get_parts_list 		= arti_jamming.get_parts_list
get_config 			= a_arti_jamming_mcm.get_config
math_ceil = math.ceil

TraderAuto = trader_autoinject.update
function trader_autoinject.update(npc)
    TraderAuto(npc)
    add_parts(npc) -- you define this function ok
end

local BASE_AMT = 15
function add_parts(npc)
	if trader_autoinject.get_trader_type(npc) == trader_autoinject.MECHANIC then
		-- purge any existing parts
		function itr(temp, item)
			if item and string.find(item:section(), "prt_w") then
				local se_itm = alife_object(item:id())
				if se_item then 
					alife_release_id(item:id())
				end
			end
		end
		npc:iterate_inventory(itr)
		-- generate an amount of parts based on trader type
		local tbl = {}
		local supply_level = trader_autoinject.supply_level(npc, true) or 1
		print_dbg("npc %s has supply level %s", npc:name(), supply_level)
		for i=1,supply_level * BASE_AMT do
			local part = parts_list[math.random(#parts_list)]
			print_dbg("Adding %s to trader %s", part, npc:name())
			if tbl[part] then
				tbl[part] = tbl[part] + 1
			else
				tbl[part] = 1
			end
		end
		if supply_level > 1 then
			tbl["partskit_tool"] = 1
		end
		-- add the parts
		trader_autoinject.spawn_items(npc, tbl, true)
	end
end

function on_get_item_cost(kind, obj, profile, calculated_cost, ret)
	-- ret.new_cost = 500
	if profile.mode == 2 then
		local sec = obj:section()
		local price = ini_prices:r_float_ex("wpo_part_prices", sec) or 0
		if price and price > 0 then 
			ret.new_cost = price * profile.discount
		end
	end 
end

DeathWeaponDrop = death_manager.set_weapon_drop_condition
-- weapon drop patching
-- read the custom drop configs and apply lagrange formula to decide condition
function death_manager.set_weapon_drop_condition(npc,itm)

	DeathWeaponDrop(npc, itm)

	local has_part = has_parts(itm)
	
	if not has_part then return end

	local rank = npc:character_community() == "zombied" and "novice" or ranks.get_obj_rank_name(npc)
	local condition = 0
	local drop_sec = get_config("altroll") and "weapons_larp" or "weapons"
	local rank_drops = ini_drops:r_string_ex(drop_sec, rank)
	if get_config("altroll") then
		print_dbg("Using larp eval")
		condition = larp.pick(larp.str_to_coords(rank_drops), 10)
	else
		conds = larp.str_explode_num(rank_drops, ",")
		condition = math.random(conds[1], conds[2])
	end
	print_dbg("New custom condition for item %s, rank %s is %s", itm:section(), rank, condition)
	condition = clamp(condition,5,100)
	condition = condition / 100
	
	itm:set_condition(condition)
	-- custom eval parts
	if has_part and get_config("altpartroll") then
		print_dbg("alt eval for weapon")
		weapon_eval_parts(itm)
	end
end

local good_breakpoint = 60
function weapon_eval_parts(wpn)
    local parts = get_parts_list(wpn)
	local con = math_ceil(wpn:condition()*100)
	local parts_data = {}
	local final_chance = 25 + math_ceil(con/2.5)
	print_dbg("Chance to beat is %s", final_chance)
	for i,part in pairs(str_explode(parts, ",")) do
		drop = math.random(100) < final_chance and "above" or "below"
		coords = ini_drops:r_string_ex("weapon_parts", drop)
		parts_data[part] = larp.pick(larp.str_to_coords(coords), 10)
		
    end

	se_save_var( wpn:id(), wpn:name(), "parts", parts_data )
end


function on_game_start()
    

	local n = ini_prices:line_count("wpo_part_prices") or 0

	for i=0, n-1 do
		local result, sec, value = ini_prices:r_line("wpo_part_prices" , i , "", "")
		parts_list[i + 1] = sec
	end
	if utils_item.on_get_item_cost then
		RegisterScriptCallback("on_get_item_cost", on_get_item_cost)
	end
end